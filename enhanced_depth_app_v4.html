<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Depth Vision Studio - Enhanced</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #cfd9df 0%, #e2ebf0 100%);
            --accent-gradient: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%);
            --surface-dark: rgba(255, 255, 255, 0.6);
            --surface-light: rgba(255, 255, 255, 0.3);
            --glass-bg: rgba(255, 255, 255, 0.18);
            --glass-border: rgba(255, 255, 255, 0.25);
            --glass-blur: 40px;
            --text-primary: #000000;
            --text-secondary: #000000;
            --text-muted: #000000;
            --text-shadow: none !important;
            --accent-blue: #0a84ff;
            --accent-purple: #5e5ce6;
            --accent-pink: #ff375f;
            --success: #30d158;
            --warning: #ffd60a;
            --error: #ff3b30;
            --shadow-lg: 0 20px 25px -5px rgba(0,0,0,0.15), 0 10px 10px -5px rgba(0,0,0,0.1);
            --shadow-xl: 0 25px 50px -12px rgba(0,0,0,0.25);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', 'SF Pro Text', 'Inter', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #ffffff 0%, #f5d7d7 50%, #d7dff5 100%);
            min-height: 100vh;
            color: var(--text-primary);
            line-height: 1.6;
            font-weight: 500;
            text-shadow: var(--text-shadow);
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(130deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1), rgba(255,255,255,0.2));
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            z-index: -2;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .background-pattern {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                repeating-linear-gradient(45deg, rgba(255,255,255,0.05) 0, rgba(255,255,255,0.05) 2px, transparent 2px, transparent 4px),
                radial-gradient(circle at 25% 25%, rgba(120,119,198,0.2) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(255,119,198,0.2) 0%, transparent 50%);
            animation: backgroundMove 30s linear infinite;
            pointer-events: none;
            z-index: -1;
        }

        .floating-shapes {
            position: fixed;
            inset: 0;
            overflow: hidden;
            z-index: -2;
            pointer-events: none;
        }

        .floating-shapes span {
            position: absolute;
            display: block;
            width: 240px;
            height: 240px;
            background: radial-gradient(circle at center, rgba(255,255,255,0.35), transparent 70%);
            filter: blur(60px);
            opacity: 0.7;
            border-radius: 50%;
            animation: float 30s linear infinite;
        }

        .floating-shapes span:nth-child(1) { top: 10%; left: 20%; animation-duration: 28s; }
        .floating-shapes span:nth-child(2) { bottom: 15%; left: 70%; animation-duration: 32s; animation-delay: 5s; }
        .floating-shapes span:nth-child(3) { top: 50%; left: 80%; animation-duration: 34s; animation-delay: 10s; }
        .floating-shapes span:nth-child(4) { top: 80%; left: 10%; animation-duration: 30s; animation-delay: 15s; }

        @keyframes float {
            0% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-60px) rotate(180deg); }
            100% { transform: translateY(0) rotate(360deg); }
        }

        .sparkle-dots {
            position: fixed;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 1;
        }

        .sparkle-dots span {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            opacity: 0.8;
            animation: sparkleMove linear infinite;
        }

        @keyframes sparkleMove {
            to { transform: translate(var(--dx), var(--dy)); }
        }

        @keyframes backgroundMove {
            0% { background-position: 0 0, 0 0, 0 0; }
            100% { background-position: 50px 50px, 0 0, 0 0; }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 24px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 48px;
            position: relative;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 4px;
            background: var(--accent-gradient);
            border-radius: 2px;
            box-shadow: 0 0 20px rgba(134, 239, 172, 0.5);
        }

        .header h1 {
            font-size: clamp(2rem, 4vw, 3.5rem);
            font-weight: 700;
            color: #000;
            margin-bottom: 16px;
            letter-spacing: -0.02em;
            text-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }

        .header p {
            font-size: 1.125rem;
            color: var(--text-secondary);
            font-weight: 400;
            text-shadow: var(--text-shadow);
        }

        .glass-card {
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur)) saturate(180%);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            box-shadow: var(--shadow-lg);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .glass-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-xl);
            border-color: rgba(255,255,255,0.7);
        }

        .upload-section {
            padding: 32px;
            margin-bottom: 32px;
        }

        .upload-area {
            border: 2px dashed var(--glass-border);
            border-radius: 16px;
            padding: 48px 32px;
            text-align: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: visible;
            backdrop-filter: blur(20px) saturate(180%);
        }


        .upload-area:hover,
        .upload-area.dragover {
            border-color: var(--accent-blue);
            background: rgba(10,132,255,0.05);
            transform: scale(1.02);
        }

        .upload-area.has-image {
            border-color: var(--success);
            background: rgba(48,209,88,0.08);
        }

        .upload-content {
            position: relative;
            z-index: 2;
        }

        .upload-content h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .upload-content p {
            color: var(--text-secondary);
            margin-bottom: 4px;
            text-shadow: var(--text-shadow);
        }


        .main-controls {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 32px;
            margin-bottom: 32px;
        }

        .method-panel {
            padding: 32px;
        }

        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 24px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .section-title::before {
            content: '';
            width: 4px;
            height: 20px;
            background: var(--accent-gradient);
            border-radius: 2px;
        }

        .preview-section {
            padding: 32px;
        }

        .preview-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 24px;
        }

        .preview-item {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .image-container {
            position: relative;
            border-radius: 16px;
            overflow: visible;
            background: var(--surface-light);
            backdrop-filter: blur(var(--glass-blur)) saturate(180%);
            min-height: 240px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--glass-border);
            transition: all 0.3s ease;
        }

        .image-container:hover {
            border-color: var(--accent-blue);
            box-shadow: 0 0 30px rgba(10,132,255,0.25);
            transform: scale(1.02);
        }

        .image-container img,
        .image-container canvas {
            max-width: 100%;
            max-height: 320px;
            width: auto;
            height: auto;
            display: block;
            border-radius: 12px;
        }

        .image-label {
            position: absolute;
            top: 12px;
            left: 12px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px) saturate(180%);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 500;
            border: 1px solid var(--glass-border);
        }

        .placeholder {
            color: var(--text-muted);
            text-align: center;
            font-style: italic;
            padding: 32px 16px;
            font-size: 0.9rem;
            text-shadow: var(--text-shadow);
        }

        .enhancement-controls {
            background: var(--surface-light);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid var(--glass-border);
            transition: all 0.3s ease;
        }

        .enhancement-controls:hover {
            border-color: rgba(255,255,255,0.7);
        }

        .enhancement-controls h5 {
            margin-bottom: 16px;
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.875rem;
            text-shadow: var(--text-shadow);
        }

        .control-value {
            background: var(--accent-blue);
            color: white;
            padding: 2px 8px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            min-width: 32px;
            text-align: center;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: var(--surface-light);
            border: 1px solid var(--glass-border);
            outline: none;
            appearance: none;
            position: relative;
            cursor: pointer;
            overflow: visible;
            backdrop-filter: blur(20px) saturate(180%);
        }

        .control-group input[type="range"]::-webkit-slider-track {
            height: 8px;
            border-radius: 4px;
            background: transparent;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 24px;
            height: 24px;
            margin-top: -8px;
            border-radius: 50%;
            background: var(--accent-gradient);
            cursor: pointer;
            border: 2px solid rgba(255,255,255,0.7);
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
            transition: transform 0.2s ease;
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }

        .control-group input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1);
        }

        .control-group select {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            font-size: 0.875rem;
            background: var(--surface-dark);
            backdrop-filter: blur(20px) saturate(180%);
            color: var(--text-primary);
            transition: all 0.3s ease;
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 12px center;
            background-repeat: no-repeat;
            background-size: 16px;
            padding-right: 40px;
        }

        .control-group select:focus {
            border-color: var(--accent-blue);
            outline: none;
            box-shadow: 0 0 0 3px rgba(10,132,255,0.2);
        }

        .method-controls {
            display: none;
            animation: fadeInUp 0.4s cubic-bezier(0.4,0,0.2,1);
        }

        .method-controls.active {
            display: block;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .color-controls {
            padding: 32px;
            margin-bottom: 32px;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px,1fr));
            gap: 24px;
            margin-bottom: 24px;
        }

        .color-input {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px;
            background: var(--surface-light);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            transition: all 0.3s ease;
        }

        .color-input:hover {
            border-color: rgba(255,255,255,0.7);
        }

        .color-input label {
            flex: 1;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .color-input input[type="color"] {
            width: 48px;
            height: 48px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            background: none;
            transition: transform 0.2s ease;
        }

        .color-input input[type="color"]:hover {
            transform: scale(1.05);
        }

        .color-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            color: var(--text-muted);
            background: var(--surface-dark);
            padding: 4px 8px;
            border-radius: 6px;
            min-width: 80px;
            text-align: center;
        }

        .color-mode-section { margin-bottom: 32px; }

        .subsection-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mode-selector {
            display: grid;
            grid-template-columns: repeat(3,1fr);
            gap: 12px;
            margin-bottom: 24px;
        }

        .mode-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px 12px;
            background: var(--surface-light);
            backdrop-filter: blur(20px) saturate(180%);
            border: 2px solid var(--glass-border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .mode-option:hover {
            border-color: var(--accent-blue);
            background: rgba(10,132,255,0.08);
            transform: translateY(-2px);
        }

        .mode-option.active {
            border-color: var(--accent-blue);
            background: rgba(10,132,255,0.12);
            box-shadow: 0 0 20px rgba(10,132,255,0.3);
        }

        .mode-icon { font-size: 1.5rem; margin-bottom: 8px; }

        .mode-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .mode-option.active .mode-label { color: var(--text-primary); }

        .depth-layers-section { margin-bottom: 32px; }

        .layers-controls {
            background: var(--surface-light);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 16px;
            padding: 24px;
            border: 1px solid var(--glass-border);
            margin-bottom: 24px;
        }

        .layer-count-control { margin-bottom: 24px; }

        .depth-layers-list {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .depth-layer-item {
            background: var(--surface-dark);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--glass-border);
            transition: all 0.3s ease;
        }

        .depth-layer-item:hover {
            border-color: rgba(255,255,255,0.7);
            transform: translateX(4px);
        }

        .layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .layer-label {
            font-weight: 600;
            font-size: 1rem;
        }

        .layer-range {
            font-size: 0.875rem;
            color: var(--text-muted);
            background: var(--glass-bg);
            padding: 6px 12px;
            border-radius: 8px;
            border: 1px solid var(--glass-border);
        }

        .layer-controls {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 20px;
            align-items: center;
        }

        .layer-color-input {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .layer-color {
            width: 56px;
            height: 56px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            border: 3px solid var(--glass-border);
            transition: all 0.3s ease;
        }

        .layer-color:hover {
            transform: scale(1.1);
            border-color: var(--accent-blue);
        }

        .layer-adjustments {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .layer-adjustments label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .layer-opacity-value,
        .layer-intensity-value {
            background: var(--accent-purple);
            color: white;
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            min-width: 36px;
            text-align: center;
        }

        .layer-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .btn-layer {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--glass-bg);
            color: var(--text-secondary);
            border: 1px solid var(--glass-border);
        }

        .btn-layer:hover {
            background: var(--accent-blue);
            color: white;
            transform: translateY(-1px);
        }

        .edge-controls {
            background: var(--surface-light);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 16px;
            padding: 24px;
            margin: 24px 0;
            border: 1px solid var(--glass-border);
        }

        .edge-toggle-section {
            margin-bottom: 24px;
            padding: 20px;
            background: var(--surface-dark);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 12px;
            border: 1px solid var(--glass-border);
        }

        .toggle-control {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 32px;
        }

        .toggle-switch input { opacity: 0; width: 0; height: 0; }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
            border-radius: 32px;
            backdrop-filter: blur(var(--glass-blur)) saturate(180%);
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 2px;
            bottom: 2px;
            background: var(--surface-dark);
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        input:checked + .toggle-slider {
            background: var(--accent-gradient);
            border-color: rgba(10,132,255,0.5);
            box-shadow: 0 0 12px rgba(10,132,255,0.4);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.25);
        }

        .toggle-info { display: flex; flex-direction: column; }

        .toggle-label {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 1rem;
        }

        .toggle-description {
            font-size: 0.875rem;
            color: var(--text-muted);
        }

        .edge-settings {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .edge-settings.disabled {
            opacity: 0.3;
            pointer-events: none;
            transform: translateY(-10px);
        }

        .edge-transparency-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--glass-border);
        }

        .transparency-toggle {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .transparency-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--accent-blue);
        }

        .transparency-toggle label {
            color: var(--text-secondary);
            font-size: 0.875rem;
            font-weight: 500;
        }

        .gradient-preview {
            height: 60px;
            border-radius: 12px;
            margin: 24px 0;
            background: linear-gradient(to right, #0000ff, #ff0000);
            border: 1px solid var(--glass-border);
            position: relative;
            overflow: hidden;
        }

        .gradient-preview::after {
            content: 'Live Depth Layers Preview';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 0.875rem;
            font-weight: 600;
            text-shadow: 0 2px 8px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.25);
            padding: 4px 12px;
            border-radius: 20px;
            backdrop-filter: blur(4px) saturate(180%);
        }

        .btn {
            padding: 12px 24px;
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
            background: var(--glass-bg);
            color: var(--text-primary);
            backdrop-filter: blur(var(--glass-blur)) saturate(180%);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before { left: 100%; }

        .btn:hover:not(:disabled) {
            transform: translateY(-1px) scale(1.03);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-primary {
            background: var(--accent-gradient);
            color: white;
            box-shadow: 0 2px 8px rgba(10,132,255,0.25);
        }

        .btn-primary:hover:not(:disabled) {
            box-shadow: 0 4px 15px rgba(10,132,255,0.35);
        }

        .btn-secondary {
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur)) saturate(180%);
            color: var(--text-primary);
            border: 1px solid var(--glass-border);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--surface-dark);
            border-color: rgba(255,255,255,0.5);
        }

        .btn-success {
            background: linear-gradient(135deg, #30d158, #34c759);
            color: white;
            box-shadow: 0 2px 8px rgba(48,209,88,0.25);
        }

        .btn-success:hover:not(:disabled) {
            box-shadow: 0 4px 15px rgba(48,209,88,0.35);
        }

        .btn-small { padding: 8px 16px; font-size: 0.75rem; }

        .action-buttons {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            margin-top: 24px;
            justify-content: center;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--surface-light);
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            overflow: hidden;
            margin: 16px 0;
            position: relative;
            backdrop-filter: blur(var(--glass-blur)) saturate(180%);
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-gradient);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
            position: relative;
            box-shadow: 0 0 6px rgba(10,132,255,0.4) inset;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .loading { display: none; text-align: center; padding: 24px; }

        .spinner {
            border: 3px solid #e5e7eb;
            border-top: 3px solid var(--accent-blue);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin { 0% { transform: rotate(0deg);} 100% { transform: rotate(360deg);} }

        .status-message {
            padding: 16px 20px;
            border-radius: 12px;
            margin: 16px 0;
            font-weight: 500;
            border-left: 4px solid;
            backdrop-filter: blur(20px) saturate(180%);
        }

        .status-success {
            background: rgba(48,209,88,0.1);
            color: #30d158;
            border-left-color: #30d158;
        }

        .status-error {
            background: rgba(255,59,48,0.1);
            color: #ff3b30;
            border-left-color: #ff3b30;
        }

        .status-info {
            background: rgba(10,132,255,0.1);
            color: #0a84ff;
            border-left-color: #0a84ff;
        }

        #fileInput { display: none; }

        .model-info {
            background: var(--surface-light);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 12px;
            padding: 16px;
            margin-top: 16px;
            font-size: 0.875rem;
            color: var(--text-secondary);
            border: 1px solid var(--glass-border);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-top: 16px;
            gap: 12px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--accent-blue);
        }

        .checkbox-group label {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .live-preview-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: var(--success);
            border-radius: 50%;
            margin-left: 12px;
            animation: pulse 2s infinite;
            box-shadow: 0 0 10px var(--success);
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        .color-mode-content { display: none; margin-bottom: 24px; }
        .color-mode-content.active { display: block; }

        @media (max-width: 1200px) {
            .main-controls { grid-template-columns: 1fr; }
            .preview-grid { grid-template-columns: 1fr 1fr; }
        }

        @media (max-width: 768px) {
            .container { padding: 16px; }
            .preview-grid { grid-template-columns: 1fr; }
            .color-grid { grid-template-columns: 1fr; }
            .main-controls { grid-template-columns: 1fr; gap: 24px; }
            .action-buttons { justify-content: center; }
            .btn { flex: 1; min-width: 120px; }
            .mode-selector { grid-template-columns: 1fr; }
            .layer-controls { grid-template-columns: 1fr; gap: 16px; }
        }

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #e5e7eb; }
        ::-webkit-scrollbar-thumb { background: var(--accent-blue); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent-purple); }

        @media (prefers-color-scheme: dark) {
            :root {
                --text-primary: #000000;
                --text-secondary: #000000;
                --text-muted: #000000;
                --surface-dark: rgba(0,0,0,0.6);
                --surface-light: rgba(255,255,255,0.1);
                --glass-bg: rgba(255,255,255,0.12);
                --glass-border: rgba(255,255,255,0.25);
                --text-shadow: 0 1px 3px rgba(0,0,0,0.7);
            }

            body {
                background: linear-gradient(135deg, #ffffff 0%, #f5d7d7 50%, #d7dff5 100%);
                color: var(--text-primary);
            }
        }
    </style>
</head>
<body>
     <div class="background-pattern"></div>
    <div class="floating-shapes">
       <span></span><span></span><span></span><span></span>
    </div>
  

    <div class="container">
        <div class="header">
            <h1>AI Depth Vision Studio</h1>
            <p>Advanced depth estimation with enhanced layer-based chromostereopsis effects</p>
        </div>
        <div class="sparkle-dots"></div>
        <div class="upload-section glass-card">
            <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
                <div class="upload-content">
                    <h3>📤 Upload Your Image</h3>
                    <p>Drop an image here or click to browse</p>
                    <p style="font-size: 0.875rem; color: var(--text-muted); margin-top: 8px;">Supports: JPG, PNG, WebP (Max: 10MB)</p>
                </div>
            </div>
            <input type="file" id="fileInput" accept="image/*" />
        </div>

        <div class="main-controls">
            <div class="method-panel glass-card">
                <h3 class="section-title">Depth Estimation Method</h3>
                <div class="control-group">
                    <select id="methodSelect">
                        <option value="">Select AI Model...</option>
                        <option value="depth-anything-v2">Depth Anything V2 (SOTA 2024)</option>
                        <option value="midas">MiDaS 3.1 (Robust & Fast)</option>
                        <option value="marigold">Marigold (Diffusion-based)</option>
                        <option value="tfjs-depth">TensorFlow.js Portrait Depth</option>
                        <option value="depth-pro">Depth Pro (Apple - Metric)</option>
                    </select>
                </div>

                <!-- Method-specific controls -->
                <div id="depth-anything-v2-controls" class="method-controls">
                    <div class="control-group">
                        <label>Model Size:</label>
                        <select id="da2-model-size">
                            <option value="vits">ViT-Small (Fast)</option>
                            <option value="vitb" selected>ViT-Base (Balanced)</option>
                            <option value="vitl">ViT-Large (Best Quality)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Processing Resolution: <span class="control-value" id="da2-res-value">768</span></label>
                        <input type="range" id="da2-resolution" min="384" max="1024" value="768" step="64">
                    </div>
                    <div class="control-group">
                        <label>Confidence Threshold: <span class="control-value" id="da2-conf-value">0.5</span></label>
                        <input type="range" id="da2-confidence" min="0.1" max="1.0" value="0.5" step="0.1">
                    </div>
                    <div class="model-info">
                        <strong>Depth Anything V2:</strong> State-of-the-art foundation model with excellent performance on diverse scenes.
                    </div>
                </div>

                <div id="midas-controls" class="method-controls">
                    <div class="control-group">
                        <label>Model Variant:</label>
                        <select id="midas-model">
                            <option value="dpt_swin2_large_384">DPT-Swin2-Large (Best)</option>
                            <option value="dpt_large_384" selected>DPT-Large (Good)</option>
                            <option value="dpt_hybrid_384">DPT-Hybrid (Fast)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Input Resolution: <span class="control-value" id="midas-res-value">384</span></label>
                        <input type="range" id="midas-resolution" min="256" max="768" value="384" step="64">
                    </div>
                    <div class="control-group">
                        <label>Alpha Value: <span class="control-value" id="midas-alpha-value">0.6</span></label>
                        <input type="range" id="midas-alpha" min="0.1" max="1.0" value="0.6" step="0.1">
                    </div>
                    <div class="model-info">
                        <strong>MiDaS 3.1:</strong> Robust monocular depth estimation with multi-objective optimization.
                    </div>
                </div>

                <div id="marigold-controls" class="method-controls">
                    <div class="control-group">
                        <label>Denoising Steps: <span class="control-value" id="marigold-steps-value">10</span></label>
                        <input type="range" id="marigold-steps" min="4" max="50" value="10" step="2">
                    </div>
                    <div class="control-group">
                        <label>Ensemble Size: <span class="control-value" id="marigold-ensemble-value">4</span></label>
                        <input type="range" id="marigold-ensemble" min="1" max="10" value="4" step="1">
                    </div>
                    <div class="control-group">
                        <label>Processing Resolution: <span class="control-value" id="marigold-res-value">768</span></label>
                        <input type="range" id="marigold-resolution" min="512" max="1024" value="768" step="64">
                    </div>
                    <div class="model-info">
                        <strong>Marigold:</strong> Diffusion-based approach with high accuracy using Stable Diffusion backbone.
                    </div>
                </div>

                <div id="tfjs-depth-controls" class="method-controls">
                    <div class="control-group">
                        <label>Portrait Focus:</label>
                        <select id="tfjs-focus">
                            <option value="auto" selected>Auto Detection</option>
                            <option value="face">Face Priority</option>
                            <option value="body">Full Body</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Segmentation Quality: <span class="control-value" id="tfjs-seg-value">0.7</span></label>
                        <input type="range" id="tfjs-segmentation" min="0.3" max="1.0" value="0.7" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Depth Smoothing: <span class="control-value" id="tfjs-smooth-value">0.5</span></label>
                        <input type="range" id="tfjs-smoothing" min="0.1" max="1.0" value="0.5" step="0.1">
                    </div>
                    <div class="model-info">
                        <strong>TensorFlow.js Portrait Depth:</strong> Optimized for human portraits using MediaPipe segmentation.
                    </div>
                </div>

                <div id="depth-pro-controls" class="method-controls">
                    <div class="control-group">
                        <label>Boundary Sharpness: <span class="control-value" id="dp-sharp-value">1.0</span></label>
                        <input type="range" id="dp-sharpness" min="0.5" max="2.0" value="1.0" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Metric Scale: <span class="control-value" id="dp-scale-value">1.0</span></label>
                        <input type="range" id="dp-scale" min="0.5" max="2.0" value="1.0" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Processing Quality:</label>
                        <select id="dp-quality">
                            <option value="high" selected>High Quality</option>
                            <option value="medium">Medium Quality</option>
                            <option value="fast">Fast Processing</option>
                        </select>
                    </div>
                    <div class="model-info">
                        <strong>Depth Pro:</strong> Apple's fast metric depth estimation producing 2.25MP depth maps.
                    </div>
                </div>

                <div class="action-buttons">
                    <button class="btn btn-primary" id="generateDepth" disabled>
                        🚀 Generate Depth Map
                    </button>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="autoApplyColors" checked>
                    <label for="autoApplyColors">Auto-apply colors on generation</label>
                </div>
                
                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <p>Processing depth map...</p>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                </div>
                
                <div id="statusMessage"></div>
            </div>

            <div class="preview-section glass-card">
                <h3 class="section-title">Live Preview <span class="live-preview-indicator" id="liveIndicator" style="display: none;"></span></h3>
                <div class="preview-grid">
                    <!-- Original Image Preview -->
                    <div class="preview-item">
                        <div class="image-container">
                            <div class="image-label">Original Image</div>
                            <img id="originalImage" style="display: none;" />
                            <canvas id="originalCanvas" style="display: none;"></canvas>
                            <div id="originalPlaceholder" class="placeholder">
                                Upload an image to see preview
                            </div>
                        </div>
                        <div class="enhancement-controls">
                            <h5>Original Image Controls</h5>
                            <div class="control-group">
                                <label>Brightness <span class="control-value" id="orig-brightness-value">0</span></label>
                                <input type="range" id="orig-brightness" min="-100" max="100" value="0" step="5">
                            </div>
                            <div class="control-group">
                                <label>Contrast <span class="control-value" id="orig-contrast-value">0</span></label>
                                <input type="range" id="orig-contrast" min="-100" max="100" value="0" step="5">
                            </div>
                            <div class="control-group">
                                <label>Saturation <span class="control-value" id="orig-saturation-value">0</span></label>
                                <input type="range" id="orig-saturation" min="-100" max="100" value="0" step="5">
                            </div>
                            <button class="btn btn-secondary btn-small" id="resetOriginal">🔄 Reset</button>
                        </div>
                    </div>

                    <!-- Depth Map Preview -->
                    <div class="preview-item">
                        <div class="image-container">
                            <div class="image-label">Depth Map</div>
                            <canvas id="depthCanvas" style="display: none;"></canvas>
                            <div id="depthPlaceholder" class="placeholder">
                                Generate depth map to see preview
                            </div>
                        </div>
                        <div class="enhancement-controls">
                            <h5>Depth Map Controls</h5>
                            <div class="control-group">
                                <label>Brightness <span class="control-value" id="depth-brightness-value">0</span></label>
                                <input type="range" id="depth-brightness" min="-100" max="100" value="0" step="5">
                            </div>
                            <div class="control-group">
                                <label>Contrast <span class="control-value" id="depth-contrast-value">0</span></label>
                                <input type="range" id="depth-contrast" min="-100" max="100" value="0" step="5">
                            </div>
                            <div class="control-group">
                                <label>Depth Range <span class="control-value" id="depth-range-value">100</span></label>
                                <input type="range" id="depth-range" min="50" max="200" value="100" step="10">
                            </div>
                            <button class="btn btn-secondary btn-small" id="resetDepth">🔄 Reset</button>
                        </div>
                    </div>

                    <!-- Final Image Preview -->
                    <div class="preview-item">
                        <div class="image-container">
                            <div class="image-label">Chromostereopsis</div>
                            <canvas id="finalCanvas" style="display: none;"></canvas>
                            <div id="finalPlaceholder" class="placeholder">
                                Apply colors to see final result
                            </div>
                        </div>
                        <div class="enhancement-controls">
                            <h5>Final Image Controls</h5>
                            <div class="control-group">
                                <label>Brightness <span class="control-value" id="final-brightness-value">0</span></label>
                                <input type="range" id="final-brightness" min="-100" max="100" value="0" step="5">
                            </div>
                            <div class="control-group">
                                <label>Contrast <span class="control-value" id="final-contrast-value">0</span></label>
                                <input type="range" id="final-contrast" min="-100" max="100" value="0" step="5">
                            </div>
                            <div class="control-group">
                                <label>Saturation <span class="control-value" id="final-saturation-value">0</span></label>
                                <input type="range" id="final-saturation" min="-100" max="100" value="0" step="5">
                            </div>
                            <button class="btn btn-secondary btn-small" id="resetFinal">🔄 Reset</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="color-controls glass-card">
            <h3 class="section-title">Enhanced Depth Layer Studio</h3>
            
            <!-- Color Mode Selection -->
            <div class="color-mode-section">
                <h4 class="subsection-title">🎨 Color Mapping Mode</h4>
                <div class="mode-selector">
                    <div class="mode-option active" data-mode="simple">
                        <div class="mode-icon">🎯</div>
                        <div class="mode-label">Simple Gradient</div>
                    </div>
                    <div class="mode-option" data-mode="layers">
                        <div class="mode-icon">🌈</div>
                        <div class="mode-label">Depth Layers</div>
                    </div>
                    <div class="mode-option" data-mode="advanced">
                        <div class="mode-icon">🔬</div>
                        <div class="mode-label">Advanced HSV</div>
                    </div>
                </div>
            </div>

            <!-- Simple Mode Controls -->
            <div id="simple-mode" class="color-mode-content active">
                <div class="color-grid">
                    <div class="color-input">
                        <label>Foreground (Near):</label>
                        <input type="color" id="nearColor" value="#ff0000">
                        <span class="color-value" id="nearColorValue">#ff0000</span>
                    </div>
                    <div class="color-input">
                        <label>Background (Far):</label>
                        <input type="color" id="farColor" value="#0000ff">
                        <span class="color-value" id="farColorValue">#0000ff</span>
                    </div>
                </div>
            </div>

            <!-- Enhanced Depth Layers Mode -->
            <div id="layers-mode" class="color-mode-content">
                <div class="depth-layers-section">
                    <h4 class="subsection-title">🏔️ Depth Layers Configuration</h4>
                    
                    <div class="layers-controls">
                        <div class="layer-count-control">
                            <label>Number of Depth Layers: <span class="control-value" id="layer-count-value">3</span></label>
                            <input type="range" id="layerCount" min="2" max="8" value="3" step="1">
                        </div>
                        
                        <div class="depth-layers-list" id="depthLayersList">
                            <!-- Dynamic depth layers will be inserted here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Advanced Mode Controls -->
            <div id="advanced-mode" class="color-mode-content">
                <div class="color-grid">
                    <div class="color-input">
                        <label>Foreground:</label>
                        <input type="color" id="adv-nearColor" value="#ff0000">
                        <span class="color-value" id="adv-nearColorValue">#ff0000</span>
                    </div>
                    <div class="color-input">
                        <label>Background:</label>
                        <input type="color" id="adv-farColor" value="#0000ff">
                        <span class="color-value" id="adv-farColorValue">#0000ff</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Hue Shift <span class="control-value" id="hue-shift-value">0</span>°</label>
                    <input type="range" id="hueShift" min="-180" max="180" value="0" step="5">
                </div>
                <div class="control-group">
                    <label>Saturation Boost <span class="control-value" id="sat-boost-value">0</span>%</label>
                    <input type="range" id="saturationBoost" min="-50" max="100" value="0" step="5">
                </div>
                <div class="control-group">
                    <label>Value Contrast <span class="control-value" id="value-contrast-value">0</span>%</label>
                    <input type="range" id="valueContrast" min="-50" max="100" value="0" step="5">
                </div>
            </div>
            
            <!-- Live Gradient Preview -->
            <div class="gradient-preview-section">
                <h4 class="subsection-title">👁️ Live Preview</h4>
                <div class="gradient-preview" id="gradientPreview"></div>
            </div>
            
            <!-- Enhanced Edge Detection Settings -->
            <div class="edge-controls">
                <h4 class="subsection-title">🔍 Edge Detection & Separation</h4>
                
                <!-- Edge Toggle Controls -->
                <div class="edge-toggle-section">
                    <div class="toggle-control">
                        <label class="toggle-switch">
                            <input type="checkbox" id="enableEdges" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <div class="toggle-info">
                            <span class="toggle-label">Enable Edge Detection</span>
                            <span class="toggle-description">Apply edge colors for enhanced depth separation</span>
                        </div>
                    </div>
                    
                    <!-- Edge Transparency Option -->
                    <div class="transparency-toggle">
                        <input type="checkbox" id="edgeTransparent">
                        <label for="edgeTransparent">Use transparent edges (no edge color)</label>
                    </div>
                </div>
                
                <div class="edge-settings" id="edgeSettings">
                    <div class="control-group">
                        <label>Detection Sensitivity <span class="control-value" id="edge-threshold-value">30</span></label>
                        <input type="range" id="edgeThreshold" min="5" max="100" value="30" step="5">
                    </div>
                    <div class="control-group">
                        <label>Edge Thickness <span class="control-value" id="edge-width-value">1</span>px</label>
                        <input type="range" id="edgeWidth" min="1" max="8" value="1" step="1">
                    </div>
                    <div class="control-group">
                        <label>Separation Power <span class="control-value" id="separation-intensity-value">1.0</span></label>
                        <input type="range" id="separationIntensity" min="0.2" max="5.0" value="1.0" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Edge Feathering <span class="control-value" id="edge-feather-value">0</span>px</label>
                        <input type="range" id="edgeFeather" min="0" max="10" value="0" step="1">
                    </div>
                    
                    <!-- Edge Color Section (hidden when transparent is enabled) -->
                    <div class="edge-transparency-section" id="edgeColorSection">
                        <h5>🎨 Edge Color Configuration</h5>
                        <div class="color-input">
                            <label>Edge Separator Color:</label>
                            <input type="color" id="edgeColor" value="#000000">
                            <span class="color-value" id="edgeColorValue">#000000</span>
                        </div>
                        <div class="control-group">
                            <label>Edge Opacity <span class="control-value" id="edge-opacity-value">100</span>%</label>
                            <input type="range" id="edgeOpacity" min="0" max="100" value="100" step="5">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="action-buttons">
                <button class="btn btn-secondary" id="randomizeColors">
                    🎲 Randomize
                </button>
                <button class="btn btn-secondary" id="invertGradient">
                    🔄 Invert
                </button>
                <button class="btn btn-primary" id="applyColors" disabled>
                    🎨 Apply Colors
                </button>
                <button class="btn btn-success" id="downloadResult" disabled>
                    📥 Download Result
                </button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let originalImageData = null;
        let originalImageElement = null;
        let depthMapData = null;
        let coloredDepthData = null;
        let currentMethod = '';
        
        // Enhancement values
        let originalEnhancements = { brightness: 0, contrast: 0, saturation: 0 };
        let depthEnhancements = { brightness: 0, contrast: 0, range: 100 };
        let finalEnhancements = { brightness: 0, contrast: 0, saturation: 0 };
        
        // Enhanced edge settings
        let edgeSettings = { 
            enabled: true,
            transparent: false,
            threshold: 30, 
            width: 1, 
            separationIntensity: 1.0,
            feather: 0,
            opacity: 100
        };
        
        // Color mode and depth layers settings
        let colorMode = 'simple';
        let depthLayers = {
            count: 3,
            layers: [
                { 
                    color: '#ff0000', 
                    opacity: 100, 
                    intensity: 100, 
                    range: [0, 33],
                    name: 'Foreground'
                },
                { 
                    color: '#ffff00', 
                    opacity: 100, 
                    intensity: 100, 
                    range: [33, 66],
                    name: 'Middle'
                },
                { 
                    color: '#0000ff', 
                    opacity: 100, 
                    intensity: 100, 
                    range: [66, 100],
                    name: 'Background'
                }
            ]
        };
        
        // Advanced color settings
        let advancedSettings = {
            hueShift: 0,
            saturationBoost: 0,
            valueContrast: 0
        };

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeEventListeners();
            updateGradientPreview();
            setupDepthLayers();
        });

        function initializeEventListeners() {
            // File upload handling
            const fileInput = document.getElementById('fileInput');
            const uploadArea = document.getElementById('uploadArea');
            
            fileInput.addEventListener('change', handleFileSelect);
            
            // Drag and drop
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleDrop);
            
            // Method selection
            document.getElementById('methodSelect').addEventListener('change', handleMethodChange);
            
            // Control value updates
            setupControlUpdaters();
            
            // Enhancement controls
            setupEnhancementControls();
            
            // Color mode controls
            setupColorModeControls();
            
            // Edge controls
            setupEdgeControls();
            
            // Color controls (basic)
            document.getElementById('nearColor').addEventListener('change', updateGradientAndApplyColors);
            document.getElementById('farColor').addEventListener('change', updateGradientAndApplyColors);
            document.getElementById('edgeColor').addEventListener('change', updateGradientAndApplyColors);
            
            // Buttons
            document.getElementById('generateDepth').addEventListener('click', generateDepthMap);
            document.getElementById('invertGradient').addEventListener('click', invertGradient);
            document.getElementById('applyColors').addEventListener('click', applyColorsToDepth);
            document.getElementById('downloadResult').addEventListener('click', downloadResult);
            document.getElementById('randomizeColors').addEventListener('click', randomizeColors);
            
            // Reset buttons
            document.getElementById('resetOriginal').addEventListener('click', resetOriginalEnhancements);
            document.getElementById('resetDepth').addEventListener('click', resetDepthEnhancements);
            document.getElementById('resetFinal').addEventListener('click', resetFinalEnhancements);
        }

        function setupColorModeControls() {
            // Mode selection
            document.querySelectorAll('.mode-option').forEach(option => {
                option.addEventListener('click', handleModeChange);
            });
            
            // Advanced controls
            setupAdvancedControls();
            
            // Layer count control
            document.getElementById('layerCount').addEventListener('input', function() {
                document.getElementById('layer-count-value').textContent = this.value;
                depthLayers.count = parseInt(this.value);
                updateDepthLayers();
                updateGradientAndApplyColors();
            });
        }

        function setupAdvancedControls() {
            // Advanced color controls
            document.getElementById('adv-nearColor').addEventListener('change', updateAdvancedColors);
            document.getElementById('adv-farColor').addEventListener('change', updateAdvancedColors);
            
            // HSV controls
            document.getElementById('hueShift').addEventListener('input', function() {
                document.getElementById('hue-shift-value').textContent = this.value;
                advancedSettings.hueShift = parseInt(this.value);
                updateAdvancedColors();
            });
            
            document.getElementById('saturationBoost').addEventListener('input', function() {
                document.getElementById('sat-boost-value').textContent = this.value;
                advancedSettings.saturationBoost = parseInt(this.value);
                updateAdvancedColors();
            });
            
            document.getElementById('valueContrast').addEventListener('input', function() {
                document.getElementById('value-contrast-value').textContent = this.value;
                advancedSettings.valueContrast = parseInt(this.value);
                updateAdvancedColors();
            });
        }

        function setupEdgeControls() {
            // Edge toggle
            document.getElementById('enableEdges').addEventListener('change', function() {
                edgeSettings.enabled = this.checked;
                updateEdgeControlsVisibility();
                if (coloredDepthData) applyColorsToDepth();
            });
            
            // Edge transparency toggle
            document.getElementById('edgeTransparent').addEventListener('change', function() {
                edgeSettings.transparent = this.checked;
                updateEdgeColorVisibility();
                if (coloredDepthData) applyColorsToDepth();
            });
            
            // Edge controls
            document.getElementById('edgeThreshold').addEventListener('input', function() {
                document.getElementById('edge-threshold-value').textContent = this.value;
                edgeSettings.threshold = parseInt(this.value);
                if (coloredDepthData) applyColorsToDepth();
            });
            
            document.getElementById('edgeWidth').addEventListener('input', function() {
                document.getElementById('edge-width-value').textContent = this.value;
                edgeSettings.width = parseInt(this.value);
                if (coloredDepthData) applyColorsToDepth();
            });
            
            document.getElementById('separationIntensity').addEventListener('input', function() {
                document.getElementById('separation-intensity-value').textContent = this.value;
                edgeSettings.separationIntensity = parseFloat(this.value);
                if (coloredDepthData) applyColorsToDepth();
            });
            
            document.getElementById('edgeFeather').addEventListener('input', function() {
                document.getElementById('edge-feather-value').textContent = this.value;
                edgeSettings.feather = parseInt(this.value);
                if (coloredDepthData) applyColorsToDepth();
            });
            
            document.getElementById('edgeOpacity').addEventListener('input', function() {
                document.getElementById('edge-opacity-value').textContent = this.value;
                edgeSettings.opacity = parseInt(this.value);
                if (coloredDepthData) applyColorsToDepth();
            });
            
            // Edge color control
            document.getElementById('edgeColor').addEventListener('change', function() {
                updateColorValues();
                if (coloredDepthData && edgeSettings.enabled && !edgeSettings.transparent) {
                    applyColorsToDepth();
                }
            });
            
            // Initialize edge controls visibility
            updateEdgeControlsVisibility();
            updateEdgeColorVisibility();
        }

        function updateEdgeControlsVisibility() {
            const edgeSettingsPanel = document.getElementById('edgeSettings');
            if (edgeSettings.enabled) {
                edgeSettingsPanel.classList.remove('disabled');
            } else {
                edgeSettingsPanel.classList.add('disabled');
            }
        }

        function updateEdgeColorVisibility() {
            const edgeColorSection = document.getElementById('edgeColorSection');
            if (edgeSettings.transparent) {
                edgeColorSection.style.display = 'none';
            } else {
                edgeColorSection.style.display = 'block';
            }
        }

        function handleModeChange(event) {
            const mode = event.currentTarget.dataset.mode;
            colorMode = mode;
            
            // Update active mode option
            document.querySelectorAll('.mode-option').forEach(opt => opt.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            // Show/hide mode content
            document.querySelectorAll('.color-mode-content').forEach(content => content.classList.remove('active'));
            document.getElementById(mode + '-mode').classList.add('active');
            
            updateGradientAndApplyColors();
        }

        function setupDepthLayers() {
            updateDepthLayers();
        }

        function updateDepthLayers() {
            const layersList = document.getElementById('depthLayersList');
            const count = depthLayers.count;
            
            // Clear existing layers
            layersList.innerHTML = '';
            
            // Update layers settings
            depthLayers.layers = [];
            
            // Default colors for layers
            const defaultColors = [
                '#ff0000', '#ff8000', '#ffff00', '#80ff00', 
                '#00ff00', '#00ff80', '#00ffff', '#0080ff'
            ];
            
            // Create layer items
            for (let i = 0; i < count; i++) {
                const rangeStart = Math.round((i / count) * 100);
                const rangeEnd = Math.round(((i + 1) / count) * 100);
                
                const layerItem = document.createElement('div');
                layerItem.className = 'depth-layer-item';
                layerItem.dataset.layer = i;
                
                const defaultColor = defaultColors[i % defaultColors.length];
                const layerName = getLayerName(i, count);
                
                layerItem.innerHTML = `
                    <div class="layer-header">
                        <span class="layer-label">${layerName}</span>
                        <span class="layer-range">${rangeStart}% - ${rangeEnd}%</span>
                    </div>
                    <div class="layer-controls">
                        <div class="layer-color-input">
                            <input type="color" class="layer-color" value="${defaultColor}">
                            <span style="font-size: 0.75rem; color: var(--text-muted);">Color</span>
                        </div>
                        <div class="layer-adjustments">
                            <label>Intensity: <span class="layer-intensity-value">100</span>%</label>
                            <input type="range" class="layer-intensity" min="0" max="200" value="100" step="10">
                            <label>Opacity: <span class="layer-opacity-value">100</span>%</label>
                            <input type="range" class="layer-opacity" min="0" max="100" value="100" step="5">
                        </div>
                        <div class="layer-actions">
                            <button class="btn-layer" onclick="duplicateLayer(${i})">📋 Copy</button>
                            <button class="btn-layer" onclick="resetLayer(${i})">🔄 Reset</button>
                        </div>
                    </div>
                `;
                
                layersList.appendChild(layerItem);
                
                // Add to layers settings
                depthLayers.layers.push({
                    color: defaultColor,
                    intensity: 100,
                    opacity: 100,
                    range: [rangeStart, rangeEnd],
                    name: layerName
                });
                
                // Add event listeners
                const colorInput = layerItem.querySelector('.layer-color');
                const intensityInput = layerItem.querySelector('.layer-intensity');
                const intensityValue = layerItem.querySelector('.layer-intensity-value');
                const opacityInput = layerItem.querySelector('.layer-opacity');
                const opacityValue = layerItem.querySelector('.layer-opacity-value');
                
                colorInput.addEventListener('change', () => {
                    depthLayers.layers[i].color = colorInput.value;
                    updateGradientAndApplyColors();
                });
                
                intensityInput.addEventListener('input', () => {
                    intensityValue.textContent = intensityInput.value;
                    depthLayers.layers[i].intensity = parseInt(intensityInput.value);
                    updateGradientAndApplyColors();
                });
                
                opacityInput.addEventListener('input', () => {
                    opacityValue.textContent = opacityInput.value;
                    depthLayers.layers[i].opacity = parseInt(opacityInput.value);
                    updateGradientAndApplyColors();
                });
            }
        }

        function getLayerName(index, total) {
            if (total <= 3) {
                const names = ['Foreground', 'Middle', 'Background'];
                return names[index] || `Layer ${index + 1}`;
            } else if (total <= 5) {
                const names = ['Closest', 'Near', 'Middle', 'Far', 'Farthest'];
                return names[index] || `Layer ${index + 1}`;
            } else {
                const names = ['Closest', 'Very Near', 'Near', 'Mid-Near', 'Middle', 'Mid-Far', 'Far', 'Farthest'];
                return names[index] || `Layer ${index + 1}`;
            }
        }

        function duplicateLayer(layerIndex) {
            if (layerIndex < depthLayers.layers.length) {
                const sourceLayer = depthLayers.layers[layerIndex];
                
                // Apply source layer settings to next layer if it exists
                if (layerIndex + 1 < depthLayers.layers.length) {
                    const targetIndex = layerIndex + 1;
                    depthLayers.layers[targetIndex].color = sourceLayer.color;
                    depthLayers.layers[targetIndex].intensity = sourceLayer.intensity;
                    depthLayers.layers[targetIndex].opacity = sourceLayer.opacity;
                    
                    // Update UI
                    const targetLayerItem = document.querySelector(`[data-layer="${targetIndex}"]`);
                    targetLayerItem.querySelector('.layer-color').value = sourceLayer.color;
                    targetLayerItem.querySelector('.layer-intensity').value = sourceLayer.intensity;
                    targetLayerItem.querySelector('.layer-intensity-value').textContent = sourceLayer.intensity;
                    targetLayerItem.querySelector('.layer-opacity').value = sourceLayer.opacity;
                    targetLayerItem.querySelector('.layer-opacity-value').textContent = sourceLayer.opacity;
                    
                    updateGradientAndApplyColors();
                    showStatus(`Layer ${layerIndex + 1} settings copied to Layer ${targetIndex + 1}`, 'success');
                } else {
                    showStatus('No target layer available for copying', 'info');
                }
            }
        }

        function resetLayer(layerIndex) {
            if (layerIndex < depthLayers.layers.length) {
                const defaultColors = [
                    '#ff0000', '#ff8000', '#ffff00', '#80ff00', 
                    '#00ff00', '#00ff80', '#00ffff', '#0080ff'
                ];
                
                const defaultColor = defaultColors[layerIndex % defaultColors.length];
                depthLayers.layers[layerIndex].color = defaultColor;
                depthLayers.layers[layerIndex].intensity = 100;
                depthLayers.layers[layerIndex].opacity = 100;
                
                // Update UI
                const layerItem = document.querySelector(`[data-layer="${layerIndex}"]`);
                layerItem.querySelector('.layer-color').value = defaultColor;
                layerItem.querySelector('.layer-intensity').value = 100;
                layerItem.querySelector('.layer-intensity-value').textContent = 100;
                layerItem.querySelector('.layer-opacity').value = 100;
                layerItem.querySelector('.layer-opacity-value').textContent = 100;
                
                updateGradientAndApplyColors();
                showStatus(`Layer ${layerIndex + 1} reset to defaults`, 'success');
            }
        }

        function updateAdvancedColors() {
            updateColorValues();
            updateGradientAndApplyColors();
        }

        function randomizeColors() {
            const getRandomColor = () => {
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', 
                               '#ff8000', '#8000ff', '#0080ff', '#80ff00', '#ff0080', '#0040ff'];
                return colors[Math.floor(Math.random() * colors.length)];
            };
            
            switch (colorMode) {
                case 'simple':
                    document.getElementById('nearColor').value = getRandomColor();
                    document.getElementById('farColor').value = getRandomColor();
                    break;
                case 'advanced':
                    document.getElementById('adv-nearColor').value = getRandomColor();
                    document.getElementById('adv-farColor').value = getRandomColor();
                    break;
                case 'layers':
                    document.querySelectorAll('.layer-color').forEach((colorInput, index) => {
                        const newColor = getRandomColor();
                        colorInput.value = newColor;
                        if (index < depthLayers.layers.length) {
                            depthLayers.layers[index].color = newColor;
                        }
                    });
                    break;
            }
            
            updateColorValues();
            updateGradientAndApplyColors();
        }

        function updateColorValues() {
            document.getElementById('nearColorValue').textContent = document.getElementById('nearColor').value;
            document.getElementById('farColorValue').textContent = document.getElementById('farColor').value;
            document.getElementById('edgeColorValue').textContent = document.getElementById('edgeColor').value;
            document.getElementById('adv-nearColorValue').textContent = document.getElementById('adv-nearColor').value;
            document.getElementById('adv-farColorValue').textContent = document.getElementById('adv-farColor').value;
        }

        function setupControlUpdaters() {
            // Depth Anything V2
            document.getElementById('da2-resolution').addEventListener('input', function() {
                document.getElementById('da2-res-value').textContent = this.value;
            });
            document.getElementById('da2-confidence').addEventListener('input', function() {
                document.getElementById('da2-conf-value').textContent = this.value;
            });
            
            // MiDaS
            document.getElementById('midas-resolution').addEventListener('input', function() {
                document.getElementById('midas-res-value').textContent = this.value;
            });
            document.getElementById('midas-alpha').addEventListener('input', function() {
                document.getElementById('midas-alpha-value').textContent = this.value;
            });
            
            // Marigold
            document.getElementById('marigold-steps').addEventListener('input', function() {
                document.getElementById('marigold-steps-value').textContent = this.value;
            });
            document.getElementById('marigold-ensemble').addEventListener('input', function() {
                document.getElementById('marigold-ensemble-value').textContent = this.value;
            });
            document.getElementById('marigold-resolution').addEventListener('input', function() {
                document.getElementById('marigold-res-value').textContent = this.value;
            });
            
            // TensorFlow.js
            document.getElementById('tfjs-segmentation').addEventListener('input', function() {
                document.getElementById('tfjs-seg-value').textContent = this.value;
            });
            document.getElementById('tfjs-smoothing').addEventListener('input', function() {
                document.getElementById('tfjs-smooth-value').textContent = this.value;
            });
            
            // Depth Pro
            document.getElementById('dp-sharpness').addEventListener('input', function() {
                document.getElementById('dp-sharp-value').textContent = this.value;
            });
            document.getElementById('dp-scale').addEventListener('input', function() {
                document.getElementById('dp-scale-value').textContent = this.value;
            });
        }

        function setupEnhancementControls() {
            // Original image enhancements
            document.getElementById('orig-brightness').addEventListener('input', function() {
                document.getElementById('orig-brightness-value').textContent = this.value;
                originalEnhancements.brightness = parseInt(this.value);
                updateOriginalImage();
            });
            document.getElementById('orig-contrast').addEventListener('input', function() {
                document.getElementById('orig-contrast-value').textContent = this.value;
                originalEnhancements.contrast = parseInt(this.value);
                updateOriginalImage();
            });
            document.getElementById('orig-saturation').addEventListener('input', function() {
                document.getElementById('orig-saturation-value').textContent = this.value;
                originalEnhancements.saturation = parseInt(this.value);
                updateOriginalImage();
            });
            
            // Depth map enhancements
            document.getElementById('depth-brightness').addEventListener('input', function() {
                document.getElementById('depth-brightness-value').textContent = this.value;
                depthEnhancements.brightness = parseInt(this.value);
                updateDepthMap();
            });
            document.getElementById('depth-contrast').addEventListener('input', function() {
                document.getElementById('depth-contrast-value').textContent = this.value;
                depthEnhancements.contrast = parseInt(this.value);
                updateDepthMap();
            });
            document.getElementById('depth-range').addEventListener('input', function() {
                document.getElementById('depth-range-value').textContent = this.value;
                depthEnhancements.range = parseInt(this.value);
                updateDepthMap();
            });
            
            // Final image enhancements
            document.getElementById('final-brightness').addEventListener('input', function() {
                document.getElementById('final-brightness-value').textContent = this.value;
                finalEnhancements.brightness = parseInt(this.value);
                updateFinalImage();
            });
            document.getElementById('final-contrast').addEventListener('input', function() {
                document.getElementById('final-contrast-value').textContent = this.value;
                finalEnhancements.contrast = parseInt(this.value);
                updateFinalImage();
            });
            document.getElementById('final-saturation').addEventListener('input', function() {
                document.getElementById('final-saturation-value').textContent = this.value;
                finalEnhancements.saturation = parseInt(this.value);
                updateFinalImage();
            });
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                loadImage(file);
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.currentTarget.classList.remove('dragover');
        }

        function handleDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                loadImage(files[0]);
            }
        }

        function loadImage(file) {
            if (!file.type.startsWith('image/')) {
                showStatus('Please select a valid image file.', 'error');
                return;
            }
            
            if (file.size > 10 * 1024 * 1024) {
                showStatus('Image file is too large. Please choose a file under 10MB.', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    originalImageElement = img;
                    originalImageData = e.target.result;
                    
                    // Display original image
                    displayOriginalImage();
                    
                    // Update upload area
                    const uploadArea = document.getElementById('uploadArea');
                    uploadArea.classList.add('has-image');
                    uploadArea.querySelector('.upload-content').innerHTML = `
                        <h3>✅ Image Loaded</h3>
                        <p>${file.name}</p>
                        <p style="font-size: 0.875rem; color: var(--text-muted);">Click to change image</p>
                    `;
                    
                    // Enable controls
                    updateGenerateButton();
                    showLiveIndicator();
                    
                    showStatus('Image loaded successfully!', 'success');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function displayOriginalImage() {
            if (!originalImageElement) return;
            
            const canvas = document.getElementById('originalCanvas');
            const img = document.getElementById('originalImage');
            const placeholder = document.getElementById('originalPlaceholder');
            
            // Create enhanced version on canvas
            canvas.width = originalImageElement.width;
            canvas.height = originalImageElement.height;
            canvas.style.display = 'block';
            
            updateOriginalImage();
            
            img.style.display = 'none';
            placeholder.style.display = 'none';
        }

        function updateOriginalImage() {
            if (!originalImageElement) return;
            
            const canvas = document.getElementById('originalCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply enhancements
            const brightness = originalEnhancements.brightness;
            const contrast = originalEnhancements.contrast;
            const saturation = originalEnhancements.saturation;
            
            ctx.filter = `brightness(${100 + brightness}%) contrast(${100 + contrast}%) saturate(${100 + saturation}%)`;
            ctx.drawImage(originalImageElement, 0, 0);
            ctx.filter = 'none';
        }

        function handleMethodChange(event) {
            const method = event.target.value;
            currentMethod = method;
            
            // Hide all control panels
            document.querySelectorAll('.method-controls').forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Show selected method controls
            if (method) {
                const controlPanel = document.getElementById(method + '-controls');
                if (controlPanel) {
                    controlPanel.classList.add('active');
                }
            }
            
            updateGenerateButton();
        }

        function updateGenerateButton() {
            const generateBtn = document.getElementById('generateDepth');
            const applyBtn = document.getElementById('applyColors');
            const hasImage = originalImageData !== null;
            const hasMethod = currentMethod !== '';
            
            generateBtn.disabled = !(hasImage && hasMethod);
            
            // Enable apply colors if we have depth data
            applyBtn.disabled = !depthMapData;
        }

        function showLiveIndicator() {
            document.getElementById('liveIndicator').style.display = 'inline-block';
        }

        async function generateDepthMap() {
            if (!originalImageData || !currentMethod) {
                showStatus('Please upload an image and select a method.', 'error');
                return;
            }
            
            showLoading(true);
            showStatus('Generating depth map...', 'info');
            
            try {
                let depthData;
                
                switch (currentMethod) {
                    case 'depth-anything-v2':
                        depthData = await generateDepthAnythingV2();
                        break;
                    case 'midas':
                        depthData = await generateMiDaS();
                        break;
                    case 'marigold':
                        depthData = await generateMarigold();
                        break;
                    case 'tfjs-depth':
                        depthData = await generateTensorFlowDepth();
                        break;
                    case 'depth-pro':
                        depthData = await generateDepthPro();
                        break;
                    default:
                        throw new Error('Unknown method selected');
                }
                
                depthMapData = depthData;
                updateDepthMap();
                
                // Enable apply colors button
                document.getElementById('applyColors').disabled = false;
                
                // Auto-apply colors if enabled
                const autoApply = document.getElementById('autoApplyColors').checked;
                if (autoApply) {
                    setTimeout(() => {
                        applyColorsToDepth();
                    }, 100);
                }
                
                showStatus('Depth map generated successfully!', 'success');
                
            } catch (error) {
                console.error('Error generating depth map:', error);
                showStatus('Error generating depth map: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Enhanced color application function
        function applyColorsToDepth() {
            if (!depthMapData) {
                showStatus('Please generate a depth map first.', 'error');
                return;
            }
            
            try {
                // Get enhanced depth data
                const enhancedDepthData = applyDepthEnhancements(depthMapData);
                
                // Apply colors based on current mode
                let coloredData;
                switch (colorMode) {
                    case 'simple':
                        coloredData = applySimpleColors(enhancedDepthData);
                        break;
                    case 'layers':
                        coloredData = applyLayerColors(enhancedDepthData);
                        break;
                    case 'advanced':
                        coloredData = applyAdvancedColors(enhancedDepthData);
                        break;
                    default:
                        coloredData = applySimpleColors(enhancedDepthData);
                }
                
                coloredDepthData = coloredData;
                updateFinalImage();
                
                showStatus('Colors applied successfully!', 'success');
                
            } catch (error) {
                console.error('Error applying colors:', error);
                showStatus('Error applying colors: ' + error.message, 'error');
            }
        }

        function applySimpleColors(depthData) {
            const { data, width, height } = depthData;
            const coloredData = new Uint8ClampedArray(width * height * 4);
            
            const nearColor = hexToRgb(document.getElementById('nearColor').value);
            const farColor = hexToRgb(document.getElementById('farColor').value);
            const edgeColor = hexToRgb(document.getElementById('edgeColor').value);
            
            return applyColorsWithEdgeDetection(data, width, height, coloredData, nearColor, farColor, edgeColor);
        }

        function applyLayerColors(depthData) {
            const { data, width, height } = depthData;
            const coloredData = new Uint8ClampedArray(width * height * 4);
            
            // Find min and max depth values for normalization
            let minDepth = 255, maxDepth = 0;
            for (let i = 0; i < data.length; i++) {
                minDepth = Math.min(minDepth, data[i]);
                maxDepth = Math.max(maxDepth, data[i]);
            }
            
            // Enhanced edge detection only if enabled
            let edges = null;
            if (edgeSettings.enabled && !edgeSettings.transparent) {
                edges = detectEdgesWithWidth(data, width, height);
            }
            
            for (let i = 0; i < data.length; i++) {
                const pixelIndex = i * 4;
                
                // Check if edge detection is enabled and this pixel is an edge
                if (edgeSettings.enabled && !edgeSettings.transparent && edges && edges[i]) {
                    // Apply edge color
                    const edgeColor = hexToRgb(document.getElementById('edgeColor').value);
                    const intensity = edgeSettings.separationIntensity;
                    const opacity = edgeSettings.opacity / 100;
                    
                    coloredData[pixelIndex] = Math.min(255, edgeColor.r * intensity);
                    coloredData[pixelIndex + 1] = Math.min(255, edgeColor.g * intensity);
                    coloredData[pixelIndex + 2] = Math.min(255, edgeColor.b * intensity);
                    coloredData[pixelIndex + 3] = 255 * opacity;
                } else if (edgeSettings.enabled && edgeSettings.transparent && edges && edges[i]) {
                    // Apply transparent edge (completely transparent)
                    coloredData[pixelIndex] = 0;
                    coloredData[pixelIndex + 1] = 0;
                    coloredData[pixelIndex + 2] = 0;
                    coloredData[pixelIndex + 3] = 0;
                } else {
                    // Apply layer color based on depth
                    const normalizedDepth = maxDepth > minDepth ? 
                        (data[i] - minDepth) / (maxDepth - minDepth) : 0;
                    
                    // Apply separation intensity
                    const enhancedDepth = Math.pow(normalizedDepth, 1 / edgeSettings.separationIntensity);
                    const depthPercent = enhancedDepth * 100;
                    
                    // Find which layer this depth belongs to
                    let layerColor = { r: 0, g: 0, b: 0 };
                    let layerOpacity = 100;
                    
                    for (let j = 0; j < depthLayers.layers.length; j++) {
                        const layer = depthLayers.layers[j];
                        if (depthPercent >= layer.range[0] && depthPercent <= layer.range[1]) {
                            const baseColor = hexToRgb(layer.color);
                            const intensity = layer.intensity / 100;
                            layerOpacity = layer.opacity;
                            
                            layerColor = {
                                r: Math.round(baseColor.r * intensity),
                                g: Math.round(baseColor.g * intensity),
                                b: Math.round(baseColor.b * intensity)
                            };
                            break;
                        }
                    }
                    
                    // If no layer found, use the last layer
                    if (layerColor.r === 0 && layerColor.g === 0 && layerColor.b === 0) {
                        const lastLayer = depthLayers.layers[depthLayers.layers.length - 1];
                        const baseColor = hexToRgb(lastLayer.color);
                        const intensity = lastLayer.intensity / 100;
                        layerOpacity = lastLayer.opacity;
                        
                        layerColor = {
                            r: Math.round(baseColor.r * intensity),
                            g: Math.round(baseColor.g * intensity),
                            b: Math.round(baseColor.b * intensity)
                        };
                    }
                    
                    coloredData[pixelIndex] = layerColor.r;
                    coloredData[pixelIndex + 1] = layerColor.g;
                    coloredData[pixelIndex + 2] = layerColor.b;
                    coloredData[pixelIndex + 3] = Math.round(255 * (layerOpacity / 100));
                }
            }
            
            return { data: coloredData, width, height };
        }

        function applyAdvancedColors(depthData) {
            const { data, width, height } = depthData;
            const coloredData = new Uint8ClampedArray(width * height * 4);
            
            const nearColor = applyAdvancedAdjustments(document.getElementById('adv-nearColor').value);
            const farColor = applyAdvancedAdjustments(document.getElementById('adv-farColor').value);
            const edgeColor = hexToRgb(document.getElementById('edgeColor').value);
            
            return applyColorsWithEdgeDetection(data, width, height, coloredData, hexToRgb(nearColor), hexToRgb(farColor), edgeColor);
        }

        function applyColorsWithEdgeDetection(data, width, height, coloredData, nearColor, farColor, edgeColor) {
            // Find min and max depth values for normalization
            let minDepth = 255, maxDepth = 0;
            for (let i = 0; i < data.length; i++) {
                minDepth = Math.min(minDepth, data[i]);
                maxDepth = Math.max(maxDepth, data[i]);
            }
            
            // Enhanced edge detection only if enabled
            let edges = null;
            if (edgeSettings.enabled && !edgeSettings.transparent) {
                edges = detectEdgesWithWidth(data, width, height);
            }
            
            for (let i = 0; i < data.length; i++) {
                const pixelIndex = i * 4;
                
                // Check if edge detection is enabled and this pixel is an edge
                if (edgeSettings.enabled && !edgeSettings.transparent && edges && edges[i]) {
                    // Apply edge color
                    const intensity = edgeSettings.separationIntensity;
                    const opacity = edgeSettings.opacity / 100;
                    
                    coloredData[pixelIndex] = Math.min(255, edgeColor.r * intensity);
                    coloredData[pixelIndex + 1] = Math.min(255, edgeColor.g * intensity);
                    coloredData[pixelIndex + 2] = Math.min(255, edgeColor.b * intensity);
                    coloredData[pixelIndex + 3] = 255 * opacity;
                } else if (edgeSettings.enabled && edgeSettings.transparent && edges && edges[i]) {
                    // Apply transparent edge (completely transparent)
                    coloredData[pixelIndex] = 0;
                    coloredData[pixelIndex + 1] = 0;
                    coloredData[pixelIndex + 2] = 0;
                    coloredData[pixelIndex + 3] = 0;
                } else {
                    // Normalize depth value
                    const normalizedDepth = maxDepth > minDepth ? 
                        (data[i] - minDepth) / (maxDepth - minDepth) : 0;
                    
                    // Apply separation intensity to enhance chromostereopsis effect
                    const enhancedDepth = Math.pow(normalizedDepth, 1 / edgeSettings.separationIntensity);
                    
                    // Interpolate between far and near colors
                    const r = Math.round(farColor.r + (nearColor.r - farColor.r) * enhancedDepth);
                    const g = Math.round(farColor.g + (nearColor.g - farColor.g) * enhancedDepth);
                    const b = Math.round(farColor.b + (nearColor.b - farColor.b) * enhancedDepth);
                    
                    coloredData[pixelIndex] = r;
                    coloredData[pixelIndex + 1] = g;
                    coloredData[pixelIndex + 2] = b;
                    coloredData[pixelIndex + 3] = 255;
                }
            }
            
            return { data: coloredData, width, height };
        }

        function applyAdvancedAdjustments(hexColor) {
            // Convert hex to HSV, apply adjustments, convert back
            const rgb = hexToRgb(hexColor);
            let hsv = rgbToHsv(rgb.r, rgb.g, rgb.b);
            
            // Apply HSV adjustments
            hsv.h = (hsv.h + advancedSettings.hueShift) % 360;
            if (hsv.h < 0) hsv.h += 360;
            
            hsv.s = Math.max(0, Math.min(100, hsv.s + advancedSettings.saturationBoost));
            hsv.v = Math.max(0, Math.min(100, hsv.v + advancedSettings.valueContrast));
            
            const adjustedRgb = hsvToRgb(hsv.h, hsv.s, hsv.v);
            return rgbToHex(adjustedRgb.r, adjustedRgb.g, adjustedRgb.b);
        }

        function detectEdgesWithWidth(depthData, width, height) {
            const edges = new Array(width * height).fill(false);
            const threshold = edgeSettings.threshold;
            const edgeWidth = edgeSettings.width;
            const feather = edgeSettings.feather;
            
            // First pass: detect edges
            const initialEdges = new Array(width * height).fill(false);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    const current = depthData[idx];
                    
                    const neighbors = [
                        depthData[idx - width - 1], depthData[idx - width], depthData[idx - width + 1],
                        depthData[idx - 1],                              depthData[idx + 1],
                        depthData[idx + width - 1], depthData[idx + width], depthData[idx + width + 1]
                    ];
                    
                    let maxGradient = 0;
                    for (const neighbor of neighbors) {
                        maxGradient = Math.max(maxGradient, Math.abs(current - neighbor));
                    }
                    
                    initialEdges[idx] = maxGradient > threshold;
                }
            }
            
            // Second pass: dilate edges based on edge width and apply feathering
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    
                    let isNearEdge = false;
                    let minDistance = Infinity;
                    
                    for (let dy = -edgeWidth - feather; dy <= edgeWidth + feather && !isNearEdge; dy++) {
                        for (let dx = -edgeWidth - feather; dx <= edgeWidth + feather && !isNearEdge; dx++) {
                            const ny = y + dy;
                            const nx = x + dx;
                            
                            if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                const neighborIdx = ny * width + nx;
                                if (initialEdges[neighborIdx]) {
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    minDistance = Math.min(minDistance, distance);
                                    
                                    if (distance <= edgeWidth) {
                                        isNearEdge = true;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Apply feathering for soft edges
                    if (feather > 0 && minDistance <= edgeWidth + feather) {
                        const featherFactor = Math.max(0, (edgeWidth + feather - minDistance) / feather);
                        edges[idx] = featherFactor > 0.5;
                    } else {
                        edges[idx] = isNearEdge;
                    }
                }
            }
            
            return edges;
        }

        function updateGradientPreview() {
            const preview = document.getElementById('gradientPreview');
            let gradientCSS = '';
            
            switch (colorMode) {
                case 'simple':
                    const nearColor = document.getElementById('nearColor').value;
                    const farColor = document.getElementById('farColor').value;
                    gradientCSS = `linear-gradient(to right, ${farColor}, ${nearColor})`;
                    break;
                    
                case 'advanced':
                    const advNearColor = applyAdvancedAdjustments(document.getElementById('adv-nearColor').value);
                    const advFarColor = applyAdvancedAdjustments(document.getElementById('adv-farColor').value);
                    gradientCSS = `linear-gradient(to right, ${advFarColor}, ${advNearColor})`;
                    break;
                    
                case 'layers':
                    const layerColors = depthLayers.layers.map(layer => {
                        const opacity = layer.opacity / 100;
                        const rgb = hexToRgb(layer.color);
                        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                    });
                    gradientCSS = `linear-gradient(to right, ${layerColors.join(', ')})`;
                    break;
                    
                default:
                    gradientCSS = `linear-gradient(to right, #0000ff, #ff0000)`;
            }
            
            preview.style.background = gradientCSS;
            updateColorValues();
        }

        function updateGradientAndApplyColors() {
            updateGradientPreview();
            if (depthMapData) {
                applyColorsToDepth();
            }
        }

        function invertGradient() {
            switch (colorMode) {
                case 'simple':
                    const nearColor = document.getElementById('nearColor');
                    const farColor = document.getElementById('farColor');
                    const tempColor = nearColor.value;
                    nearColor.value = farColor.value;
                    farColor.value = tempColor;
                    break;
                case 'advanced':
                    const advNearColor = document.getElementById('adv-nearColor');
                    const advFarColor = document.getElementById('adv-farColor');
                    const tempAdvColor = advNearColor.value;
                    advNearColor.value = advFarColor.value;
                    advFarColor.value = tempAdvColor;
                    break;
                case 'layers':
                    // Reverse the order of layer colors
                    const colors = depthLayers.layers.map(layer => layer.color);
                    colors.reverse();
                    depthLayers.layers.forEach((layer, index) => {
                        layer.color = colors[index];
                        const layerItem = document.querySelector(`[data-layer="${index}"]`);
                        if (layerItem) {
                            layerItem.querySelector('.layer-color').value = colors[index];
                        }
                    });
                    break;
            }
            
            updateGradientAndApplyColors();
        }

        function updateDepthMap() {
            if (!depthMapData) return;
            
            const canvas = document.getElementById('depthCanvas');
            const placeholder = document.getElementById('depthPlaceholder');
            const ctx = canvas.getContext('2d');
            
            canvas.width = depthMapData.width;
            canvas.height = depthMapData.height;
            canvas.style.display = 'block';
            placeholder.style.display = 'none';
            
            // Apply enhancements to depth map
            const enhancedDepthData = applyDepthEnhancements(depthMapData);
            
            // Create grayscale depth map visualization
            const imageData = ctx.createImageData(enhancedDepthData.width, enhancedDepthData.height);
            
            for (let i = 0; i < enhancedDepthData.data.length; i++) {
                const depth = enhancedDepthData.data[i];
                const pixelIndex = i * 4;
                
                imageData.data[pixelIndex] = depth;     // R
                imageData.data[pixelIndex + 1] = depth; // G
                imageData.data[pixelIndex + 2] = depth; // B
                imageData.data[pixelIndex + 3] = 255;   // A
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // If we have colored data, update that too
            if (coloredDepthData) {
                updateFinalImage();
            }
        }

        function applyDepthEnhancements(depthData) {
            const brightness = depthEnhancements.brightness;
            const contrast = depthEnhancements.contrast;
            const range = depthEnhancements.range;
            
            const enhancedData = new Uint8ClampedArray(depthData.data.length);
            
            // Apply brightness and contrast
            const contrastFactor = (259 * (contrast + 255)) / (255 * (259 - contrast));
            
            // Find min/max for range adjustment
            let minDepth = 255, maxDepth = 0;
            for (let i = 0; i < depthData.data.length; i++) {
                minDepth = Math.min(minDepth, depthData.data[i]);
                maxDepth = Math.max(maxDepth, depthData.data[i]);
            }
            
            for (let i = 0; i < depthData.data.length; i++) {
                let pixel = depthData.data[i];
                
                // Apply range adjustment
                const normalizedDepth = (pixel - minDepth) / (maxDepth - minDepth);
                const centeredRange = (range - 100) / 100;
                const adjustedDepth = (normalizedDepth - 0.5) * (1 + centeredRange) + 0.5;
                pixel = Math.max(0, Math.min(1, adjustedDepth)) * 255;
                
                // Apply contrast
                pixel = contrastFactor * (pixel - 128) + 128;
                
                // Apply brightness
                pixel = pixel + brightness;
                
                // Clamp values
                enhancedData[i] = Math.max(0, Math.min(255, pixel));
            }
            
            return { data: enhancedData, width: depthData.width, height: depthData.height };
        }

        function updateFinalImage() {
            if (!coloredDepthData) return;
            
            const canvas = document.getElementById('finalCanvas');
            const placeholder = document.getElementById('finalPlaceholder');
            const ctx = canvas.getContext('2d');
            
            canvas.width = coloredDepthData.width;
            canvas.height = coloredDepthData.height;
            canvas.style.display = 'block';
            placeholder.style.display = 'none';
            
            // Apply final enhancements
            const enhancedData = applyFinalEnhancements(coloredDepthData);
            
            const imageData = new ImageData(enhancedData.data, enhancedData.width, enhancedData.height);
            ctx.putImageData(imageData, 0, 0);
            
            // Enable download
            document.getElementById('downloadResult').disabled = false;
        }

        function applyFinalEnhancements(coloredData) {
            const brightness = finalEnhancements.brightness;
            const contrast = finalEnhancements.contrast;
            const saturation = finalEnhancements.saturation;
            
            const enhancedData = new Uint8ClampedArray(coloredData.data.length);
            const contrastFactor = (259 * (contrast + 255)) / (255 * (259 - contrast));
            const saturationFactor = (saturation + 100) / 100;
            
            for (let i = 0; i < coloredData.data.length; i += 4) {
                let r = coloredData.data[i];
                let g = coloredData.data[i + 1];
                let b = coloredData.data[i + 2];
                const a = coloredData.data[i + 3];
                
                // Apply contrast
                r = contrastFactor * (r - 128) + 128;
                g = contrastFactor * (g - 128) + 128;
                b = contrastFactor * (b - 128) + 128;
                
                // Apply brightness
                r += brightness;
                g += brightness;
                b += brightness;
                
                // Apply saturation
                const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                r = gray + saturationFactor * (r - gray);
                g = gray + saturationFactor * (g - gray);
                b = gray + saturationFactor * (b - gray);
                
                // Clamp values
                enhancedData[i] = Math.max(0, Math.min(255, r));
                enhancedData[i + 1] = Math.max(0, Math.min(255, g));
                enhancedData[i + 2] = Math.max(0, Math.min(255, b));
                enhancedData[i + 3] = a;
            }
            
            return { data: enhancedData, width: coloredData.width, height: coloredData.height };
        }

        function resetOriginalEnhancements() {
            originalEnhancements = { brightness: 0, contrast: 0, saturation: 0 };
            
            document.getElementById('orig-brightness').value = 0;
            document.getElementById('orig-contrast').value = 0;
            document.getElementById('orig-saturation').value = 0;
            
            document.getElementById('orig-brightness-value').textContent = '0';
            document.getElementById('orig-contrast-value').textContent = '0';
            document.getElementById('orig-saturation-value').textContent = '0';
            
            updateOriginalImage();
        }

        function resetDepthEnhancements() {
            depthEnhancements = { brightness: 0, contrast: 0, range: 100 };
            
            document.getElementById('depth-brightness').value = 0;
            document.getElementById('depth-contrast').value = 0;
            document.getElementById('depth-range').value = 100;
            
            document.getElementById('depth-brightness-value').textContent = '0';
            document.getElementById('depth-contrast-value').textContent = '0';
            document.getElementById('depth-range-value').textContent = '100';
            
            updateDepthMap();
        }

        function resetFinalEnhancements() {
            finalEnhancements = { brightness: 0, contrast: 0, saturation: 0 };
            
            document.getElementById('final-brightness').value = 0;
            document.getElementById('final-contrast').value = 0;
            document.getElementById('final-saturation').value = 0;
            
            document.getElementById('final-brightness-value').textContent = '0';
            document.getElementById('final-contrast-value').textContent = '0';
            document.getElementById('final-saturation-value').textContent = '0';
            
            updateFinalImage();
        }

        function downloadResult() {
            if (!coloredDepthData) {
                showStatus('Please generate and apply colors to the depth map first.', 'error');
                return;
            }
            
            // Use the final canvas with all enhancements applied
            const canvas = document.getElementById('finalCanvas');
            
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ai_depth_vision_${currentMethod}_${colorMode}_${Date.now()}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus('Image downloaded successfully!', 'success');
            }, 'image/png');
        }

        // Utility functions
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function rgbToHsv(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const diff = max - min;
            
            let h = 0;
            let s = max === 0 ? 0 : diff / max;
            let v = max;
            
            if (diff !== 0) {
                switch (max) {
                    case r: h = ((g - b) / diff) % 6; break;
                    case g: h = (b - r) / diff + 2; break;
                    case b: h = (r - g) / diff + 4; break;
                }
            }
            
            return {
                h: h * 60,
                s: s * 100,
                v: v * 100
            };
        }

        function hsvToRgb(h, s, v) {
            h /= 60;
            s /= 100;
            v /= 100;
            
            const c = v * s;
            const x = c * (1 - Math.abs((h % 2) - 1));
            const m = v - c;
            
            let r = 0, g = 0, b = 0;
            
            if (h >= 0 && h < 1) {
                r = c; g = x; b = 0;
            } else if (h >= 1 && h < 2) {
                r = x; g = c; b = 0;
            } else if (h >= 2 && h < 3) {
                r = 0; g = c; b = x;
            } else if (h >= 3 && h < 4) {
                r = 0; g = x; b = c;
            } else if (h >= 4 && h < 5) {
                r = x; g = 0; b = c;
            } else if (h >= 5 && h < 6) {
                r = c; g = 0; b = x;
            }
            
            return {
                r: Math.round((r + m) * 255),
                g: Math.round((g + m) * 255),
                b: Math.round((b + m) * 255)
            };
        }

        function showLoading(show, message = 'Processing...') {
            const loading = document.getElementById('loadingIndicator');
            const loadingText = loading.querySelector('p');
            
            if (show) {
                loadingText.textContent = message;
                loading.style.display = 'block';
            } else {
                loading.style.display = 'none';
                updateProgress(0);
            }
        }

        function updateProgress(percent) {
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = percent + '%';
        }

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.className = `status-message status-${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        // Depth generation methods (same simulation logic as before)
        async function generateDepthAnythingV2() {
            updateProgress(10);
            
            const modelSize = document.getElementById('da2-model-size').value;
            const resolution = parseInt(document.getElementById('da2-resolution').value);
            const confidence = parseFloat(document.getElementById('da2-confidence').value);
            
            updateProgress(30);
            
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = originalImageElement.width;
                canvas.height = originalImageElement.height;
                ctx.drawImage(originalImageElement, 0, 0);
                
                updateProgress(60);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const depthData = generateSimulatedDepthMap(imageData, {
                    method: 'depth-anything-v2',
                    modelSize,
                    resolution,
                    confidence
                });
                
                updateProgress(100);
                resolve(depthData);
            });
        }

        async function generateMiDaS() {
            updateProgress(10);
            
            const model = document.getElementById('midas-model').value;
            const resolution = parseInt(document.getElementById('midas-resolution').value);
            const alpha = parseFloat(document.getElementById('midas-alpha').value);
            
            updateProgress(30);
            
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = originalImageElement.width;
                canvas.height = originalImageElement.height;
                ctx.drawImage(originalImageElement, 0, 0);
                
                updateProgress(60);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const depthData = generateSimulatedDepthMap(imageData, {
                    method: 'midas',
                    model,
                    resolution,
                    alpha
                });
                
                updateProgress(100);
                resolve(depthData);
            });
        }

        async function generateMarigold() {
            updateProgress(10);
            
            const steps = parseInt(document.getElementById('marigold-steps').value);
            const ensemble = parseInt(document.getElementById('marigold-ensemble').value);
            const resolution = parseInt(document.getElementById('marigold-resolution').value);
            
            updateProgress(20);
            
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = originalImageElement.width;
                canvas.height = originalImageElement.height;
                ctx.drawImage(originalImageElement, 0, 0);
                
                updateProgress(50);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                let depthData;
                for (let i = 0; i < ensemble; i++) {
                    updateProgress(50 + (40 * i / ensemble));
                    depthData = generateSimulatedDepthMap(imageData, {
                        method: 'marigold',
                        steps,
                        ensemble,
                        resolution,
                        iteration: i
                    });
                }
                
                updateProgress(100);
                resolve(depthData);
            });
        }

        async function generateTensorFlowDepth() {
            updateProgress(10);
            
            const focus = document.getElementById('tfjs-focus').value;
            const segmentation = parseFloat(document.getElementById('tfjs-segmentation').value);
            const smoothing = parseFloat(document.getElementById('tfjs-smoothing').value);
            
            updateProgress(30);
            
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = originalImageElement.width;
                canvas.height = originalImageElement.height;
                ctx.drawImage(originalImageElement, 0, 0);
                
                updateProgress(60);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const depthData = generateSimulatedDepthMap(imageData, {
                    method: 'tfjs-depth',
                    focus,
                    segmentation,
                    smoothing
                });
                
                updateProgress(100);
                resolve(depthData);
            });
        }

        async function generateDepthPro() {
            updateProgress(10);
            
            const sharpness = parseFloat(document.getElementById('dp-sharpness').value);
            const scale = parseFloat(document.getElementById('dp-scale').value);
            const quality = document.getElementById('dp-quality').value;
            
            updateProgress(30);
            
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = originalImageElement.width;
                canvas.height = originalImageElement.height;
                ctx.drawImage(originalImageElement, 0, 0);
                
                updateProgress(60);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const depthData = generateSimulatedDepthMap(imageData, {
                    method: 'depth-pro',
                    sharpness,
                    scale,
                    quality
                });
                
                updateProgress(100);
                resolve(depthData);
            });
        }

        function generateSimulatedDepthMap(imageData, params) {
            const { data, width, height } = imageData;
            
            switch (params.method) {
                case 'depth-anything-v2':
                    return simulateDepthAnythingV2(data, width, height, params);
                case 'midas':
                    return simulateMiDaS(data, width, height, params);
                case 'marigold':
                    return simulateMarigold(data, width, height, params);
                case 'tfjs-depth':
                    return simulateTensorFlowDepth(data, width, height, params);
                case 'depth-pro':
                    return simulateDepthPro(data, width, height, params);
                default:
                    return simulateBasicDepth(data, width, height);
            }
        }

        // Simulation functions (enhanced for better depth maps)
        function simulateDepthAnythingV2(data, width, height, params) {
            const depthArray = new Uint8Array(width * height);
            
            for (let i = 0; i < width * height; i++) {
                const r = data[i * 4];
                const g = data[i * 4 + 1];
                const b = data[i * 4 + 2];
                
                const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                
                const x = i % width;
                const y = Math.floor(i / width);
                const centerX = width / 2;
                const centerY = height / 2;
                const distanceFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                const maxDistance = Math.sqrt(centerX ** 2 + centerY ** 2);
                const positionDepth = (1 - distanceFromCenter / maxDistance) * 100;
                
                const depth = (luminance * (1 - params.confidence) + positionDepth * params.confidence);
                depthArray[i] = Math.min(255, Math.max(0, depth));
            }
            
            return { data: depthArray, width, height, method: 'depth-anything-v2' };
        }

        function simulateMiDaS(data, width, height, params) {
            const depthArray = new Uint8Array(width * height);
            
            for (let i = 0; i < width * height; i++) {
                const r = data[i * 4];
                const g = data[i * 4 + 1];
                const b = data[i * 4 + 2];
                
                const intensity = (r + g + b) / 3;
                const x = i % width;
                const y = Math.floor(i / width);
                
                let edgeStrength = 0;
                if (x > 0 && x < width - 1 && y > 0 && y < height - 1) {
                    const leftIdx = i - 1;
                    const rightIdx = i + 1;
                    const topIdx = i - width;
                    const bottomIdx = i + width;
                    
                    const gradX = Math.abs((data[rightIdx * 4] + data[rightIdx * 4 + 1] + data[rightIdx * 4 + 2]) / 3 -
                                         (data[leftIdx * 4] + data[leftIdx * 4 + 1] + data[leftIdx * 4 + 2]) / 3);
                    const gradY = Math.abs((data[bottomIdx * 4] + data[bottomIdx * 4 + 1] + data[bottomIdx * 4 + 2]) / 3 -
                                         (data[topIdx * 4] + data[topIdx * 4 + 1] + data[topIdx * 4 + 2]) / 3);
                    
                    edgeStrength = Math.sqrt(gradX * gradX + gradY * gradY);
                }
                
                const depth = intensity * params.alpha + edgeStrength * (1 - params.alpha);
                depthArray[i] = Math.min(255, Math.max(0, depth));
            }
            
            return { data: depthArray, width, height, method: 'midas' };
        }

        function simulateMarigold(data, width, height, params) {
            const depthArray = new Uint8Array(width * height);
            
            for (let i = 0; i < width * height; i++) {
                const r = data[i * 4];
                const g = data[i * 4 + 1];
                const b = data[i * 4 + 2];
                
                let depth = (r * 0.2 + g * 0.7 + b * 0.1);
                
                const noise = (Math.random() - 0.5) * (50 - params.steps);
                depth += noise;
                
                if (params.iteration > 0) {
                    depth = depth * 0.7 + (Math.random() * 255) * 0.3;
                }
                
                depthArray[i] = Math.min(255, Math.max(0, depth));
            }
            
            return { data: depthArray, width, height, method: 'marigold' };
        }

        function simulateTensorFlowDepth(data, width, height, params) {
            const depthArray = new Uint8Array(width * height);
            
            for (let i = 0; i < width * height; i++) {
                const r = data[i * 4];
                const g = data[i * 4 + 1];
                const b = data[i * 4 + 2];
                
                const x = i % width;
                const y = Math.floor(i / width);
                
                const isSkinTone = (r > 95 && g > 40 && b > 20 && 
                                   r > g && r > b && 
                                   Math.abs(r - g) > 15);
                
                let depth;
                if (params.focus === 'face' && isSkinTone) {
                    depth = 200 + (Math.random() - 0.5) * 50;
                } else if (params.focus === 'body' && (isSkinTone || y > height * 0.3)) {
                    depth = 150 + (y / height) * 100;
                } else {
                    depth = 50 + (Math.random() * 100);
                }
                
                depth = depth * params.smoothing + (r + g + b) / 3 * (1 - params.smoothing);
                
                depthArray[i] = Math.min(255, Math.max(0, depth));
            }
            
            return { data: depthArray, width, height, method: 'tfjs-depth' };
        }

        function simulateDepthPro(data, width, height, params) {
            const depthArray = new Uint8Array(width * height);
            
            for (let i = 0; i < width * height; i++) {
                const r = data[i * 4];
                const g = data[i * 4 + 1];
                const b = data[i * 4 + 2];
                
                const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                const x = i % width;
                const y = Math.floor(i / width);
                
                let sharpness = 1;
                if (x > 0 && x < width - 1 && y > 0 && y < height - 1) {
                    const neighbors = [
                        data[(i - 1) * 4], data[(i + 1) * 4],
                        data[(i - width) * 4], data[(i + width) * 4]
                    ];
                    const variance = neighbors.reduce((acc, val) => acc + Math.abs(val - r), 0) / 4;
                    sharpness = 1 + (variance / 255) * params.sharpness;
                }
                
                const depth = (luminance * sharpness * params.scale);
                depthArray[i] = Math.min(255, Math.max(0, depth));
            }
            
            return { data: depthArray, width, height, method: 'depth-pro' };
        }

        function simulateBasicDepth(data, width, height) {
            const depthArray = new Uint8Array(width * height);
            
            for (let i = 0; i < width * height; i++) {
                const r = data[i * 4];
                const g = data[i * 4 + 1];
                const b = data[i * 4 + 2];
                
                const depth = (r + g + b) / 3;
                depthArray[i] = depth;
            }
            
            return { data: depthArray, width, height, method: 'basic' };
        }

        function createSparkleDots() {
            const container = document.querySelector('.sparkle-dots');
            if (!container) return;
            const colors = ['rgba(255,0,0,0.8)', 'rgba(0,0,255,0.8)'];
            const dotCount = 1000;
            for (let i = 0; i < dotCount; i++) {
                const dot = document.createElement('span');
                dot.style.backgroundColor = colors[i % 2];
                const startX = Math.random() * 100;
                const startY = Math.random() * 100;
                const endX = startX + (Math.random() - 0.5) * 20;
                const endY = startY + (Math.random() - 0.5) * 20;
                const duration = 10 + Math.random() * 20;
                const delay = -Math.random() * duration;
                dot.style.left = startX + 'vw';
                dot.style.top = startY + 'vh';
                dot.style.setProperty('--dx', (endX - startX) + 'vw');
                dot.style.setProperty('--dy', (endY - startY) + 'vh');
                dot.style.animationDuration = duration + 's';
                dot.style.animationDelay = delay + 's';
                container.appendChild(dot);
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateGradientPreview();
            createSparkleDots();
        });
    </script>
</body>
</html>

